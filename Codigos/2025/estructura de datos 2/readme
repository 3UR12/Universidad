```markdown
# Torre de Hanoi Interactiva en Python

Aplicación gráfica de la **Torre de Hanoi** desarrollada en Python usando **tkinter**.  
Incluye validaciones avanzadas y extensiones para práctica, visualización y análisis del juego.

## Características

- **Interfaz gráfica interactiva**: mover discos haciendo clic en la torre de origen y luego en la de destino.
- **Reglas automáticas**: no permite colocar un disco grande sobre uno pequeño.
- **Validaciones** de entrada, estado del juego y manejo de errores.
- **Temporizador** que inicia con el primer movimiento y se detiene al finalizar.
- **Deshacer / Rehacer** ilimitado de movimientos.
- **Verificación óptima**: muestra el mínimo teórico de movimientos y compara con tu resultado.
- **Pista**: indica el próximo movimiento de la solución óptima.
- **Resolución automática**: desde el inicio o desde el estado actual (si aún es óptimo).
- **Control de velocidad** en animaciones.
- **Paleta de colores** para identificar discos.

## Requisitos

- Python 3.x
- Tkinter (incluido por defecto en la mayoría de instalaciones de Python)

## Instalación

1. Clonar este repositorio:
   ```bash
   git clone https://github.com/usuario/torre-de-hanoi.git
   cd torre-de-hanoi
   ```
2. Ejecutar el programa:
   ```bash
   python torre_de_hanoi.py
   ```

## Cómo se usa

1. **Elegir la cantidad de discos**: usando el Spinbox (mín. 3, máx. 12) y presionando **Reiniciar** para aplicar cambios.
2. **Mover discos**: clic en la torre de origen y luego en la torre destino.
3. **Seguir las reglas**:
   - Solo se mueve un disco a la vez.
   - No colocar discos grandes sobre pequeños.
   - Mover únicamente el disco superior de cada torre.
4. **Opciones disponibles**:
   - **Deshacer/Rehacer**: retrocede o avanza en tu historial de movimientos.
   - **Pista**: sugiere el siguiente paso óptimo.
   - **Resolver desde aquí**: completa la solución desde tu estado actual (si sigues óptimo).
   - **Resolver automáticamente (inicio)**: animación desde el inicio.
   - **Velocidad**: ajusta la rapidez de animación.

## Mínimo teórico de movimientos y complejidad

El mínimo de movimientos para resolver la Torre de Hanoi con `n` discos es:

\[
Mínimo = 2^n - 1
\]

Complejidad temporal del algoritmo óptimo: **O(2^n)** movimientos.  
Complejidad espacial del generador: **O(n)** por la recursión.

| Discos | Mínimo |
|--------|--------|
| 3      | 7      |
| 4      | 15     |
| 5      | 31     |
| 6      | 63     |
| 7      | 127    |
| 8      | 255    |
| 9      | 511    |
| 10     | 1023   |
| 11     | 2047   |
| 12     | 4095   |

### Estimación de tiempo (ejecución humana)

- **Manual**: depende de la destreza.  
  Ejemplo: con 8 discos (255 movimientos mínimos), a un ritmo de 1 movimiento/segundo ≈ 4 minutos 15 segundos.
- **Automático**: configurable; en modo rápido puede completarse en pocos segundos.

## Métodos y algoritmos

### Algoritmos principales

- **`generar_movimientos_hanoi(n_discos, origen, auxiliar, destino)`**  
  Genera la secuencia óptima de movimientos recursivamente. Usado para resolver automáticamente, dar pistas y verificar el camino óptimo.

- **`validar_invariantes()`**  
  Verifica que cada torre esté estrictamente decreciente de base a cima para mantener consistencia.

- **Seguimiento del camino óptimo (prefijo)**  
  Variables: `secuencia_optima`, `indice_optimo`, `prefijo_optimo_roto`.  
  Permite ofrecer pista y resolver desde el estado actual solo si sigue el prefijo óptimo.

- **Historial Deshacer/Rehacer**  
  Pilas `pila_deshacer` y `pila_rehacer` guardan copias profundas del estado completo para navegar entre ellos.

- **Animación**  
  `iniciar_animacion()` y `animar_siguiente()` reproducen la secuencia paso a paso, según la velocidad configurada.

- **Temporizador**  
  Basado en `time.perf_counter()`, con refresco del HUD cada 200 ms.

### Métodos de interacción y control

- **Entrada y validación**: `validar_spinbox()`, `al_cambiar_discos()`, `al_reiniciar()`.
- **Eventos de usuario**: `al_clic()` para gestionar la selección de torres y mover discos.
- **Movimiento y estado**:  
  `intentar_movimiento()` verifica legalidad, aplica movimientos, actualiza contadores, valida invariantes y evalúa fin de juego.
- **Asistencia y solución**:  
  `mostrar_pista()`, `resolver_desde_aqui()`, `resolver_desde_inicio()`.
- **Renderizado**:  
  `redibujar()`, `dibujar_base_y_torres()`, `dibujar_discos()`, `dibujar_hud()`.
- **Infraestructura**:  
  `construir_interfaz()`, `reiniciar_juego()`, `establecer_estado()`, `ejecutar_seguro()`.

## Señales, sonidos y planificación

- **`self.ventana.bell()`**  
  Aviso sonoro en:
  - Movimientos ilegales (disco grande sobre pequeño).
  - Torre origen vacía.
  - Acciones inválidas durante animación.
  - No hay nada que deshacer/rehacer.

- **`messagebox.showerror()`**  
  Mensajes críticos para excepciones inesperadas o violaciones de invariantes.

- **`widget.state(["disabled"])` / `widget.state(["!disabled"])`**  
  Deshabilita controles durante animaciones para evitar inconsistencias.

- **`widget.after(ms, callback)`**  
  Planifica pasos de animación y actualizaciones de temporizador.

- **`widget.after_cancel(id)`**  
  Cancela tareas programadas, como el temporizador.

- **`canvas.bind("<Button-1>", handler)`**  
  Asocia clics del ratón a acciones de juego.

## Diseño y decisiones clave

- Representación de torres como listas (pilas) para facilidad de `pop()`/`append()`.
- Uso de `copy.deepcopy` para asegurar que deshacer/rehacer no comparta referencias mutables.
- Uso de prefijo óptimo para optimizar pista y resolución parcial sin recomputar soluciones.
- Validación de invariantes post-movimiento para garantizar la integridad.
- HUD reactivo que combina información de movimientos, tiempo y eficiencia.

## Licencia

MIT

